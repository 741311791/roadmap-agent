# 路线图任务架构重构方案

> **日期**: 2025-12-12  
> **类型**: 架构改进  
> **优先级**: 高  
> **状态**: 📋 设计方案

---

## 📋 问题分析

你的分析完全正确！让我们系统地梳理问题：

### 问题 A：`roadmap_metadata.task_id` 设计过于限制

**当前表结构**：
```sql
CREATE TABLE roadmap_metadata (
    roadmap_id VARCHAR PRIMARY KEY,
    task_id VARCHAR NOT NULL,  -- ❌ 只能存储创建任务的 ID
    ...
);
```

**问题**：
- 一个路线图会有**多个任务**（创建 + 多次重试）
- 但 `task_id` 字段只能存储一个（创建时的任务）
- 重试任务无法关联到路线图
- 导致 `checkRoadmapStatusQuick()` 无法检测到重试任务

**你的建议正确**：确实应该解耦，建立多对多关系！

### 问题 B：重试任务没有持久化

| 任务类型 | 创建 `RoadmapTask`? | 更新 `roadmap_metadata`? | WebSocket? |
|---------|-------------------|-------------------------|-----------|
| **路线图创建** | ✅ 是 | ✅ 是 | ✅ 是 |
| **批量重试** (`/retry-failed`) | ✅ 是 | ❌ 否 | ✅ 是 |
| **单 Concept 重试** (`/tutorial/retry`) | ❌ **否** | ❌ 否 | ✅ 是 |

**证据**（来自 `backend/app/api/v1/endpoints/generation.py`）：

```python
@router.post("/{roadmap_id}/concepts/{concept_id}/tutorial/retry")
async def retry_tutorial(...):
    task_id = _generate_retry_task_id(roadmap_id, concept_id, "tutorial")
    
    # ❌ 问题：没有调用 repo.create_task()
    # ❌ 问题：没有持久化任务记录
    # ✅ 只有：WebSocket 事件推送
    
    # 直接开始生成
    await _update_concept_status_in_framework(...)
    await notification_service.publish_concept_start(task_id, ...)
```

**后果**：
1. ❌ tasks 表中没有记录
2. ❌ execution_logs 表中没有日志
3. ❌ WebSocket 断开后无法查询状态
4. ❌ 任务被 kill 后无法检测僵尸状态
5. ❌ 没有审计追踪

### 问题 C：僵尸状态检测失效

**当前逻辑**（`backend/app/api/v1/roadmap.py:367-376`）：

```python
# ❌ 只检查创建任务
task = await repo.get_task(metadata.task_id)  
has_active_task = task and task.status in ['pending', 'processing', ...]

# ❌ 重试任务未被检查
# 结果：误报僵尸状态
```

**场景复现**：
1. 用户创建路线图 → `task_id = "task-001"`（已完成）
2. 用户重试资源生成 → `task_id = "task-002"`（活跃，**但未持久化**）
3. 用户切换 tab 后返回
4. 前端调用 `checkRoadmapStatusQuick(roadmap_id)`
5. 后端检查 `metadata.task_id`（`"task-001"`）→ 状态：completed
6. 后端发现 `resources_status = 'generating'` 但没有活跃任务
7. **误判**：标记为"僵尸状态" ❌

---

## ✅ 解决方案：任务-路线图关联表

### 新表结构设计

#### 1. 新增 `roadmap_task_links` 表（多对多关系）

```sql
CREATE TABLE roadmap_task_links (
    id SERIAL PRIMARY KEY,
    roadmap_id VARCHAR NOT NULL,
    task_id VARCHAR NOT NULL,
    task_type VARCHAR NOT NULL,  -- 'creation', 'retry_tutorial', 'retry_resources', 'retry_quiz', 'retry_batch'
    concept_id VARCHAR,           -- 单 Concept 重试时填写
    content_type VARCHAR,         -- 'tutorial', 'resources', 'quiz'（单 Concept 重试时填写）
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    
    UNIQUE(roadmap_id, task_id),
    INDEX(roadmap_id, created_at DESC),  -- 查询路线图的最新任务
    INDEX(task_id)
);
```

**优势**：
- ✅ 一个路线图可以有多个任务
- ✅ 可以查询所有任务（创建 + 重试）
- ✅ 保留完整的审计追踪
- ✅ 支持准确的僵尸状态检测

#### 2. `roadmap_metadata.task_id` 处理方案

**方案 A：保留以向后兼容**
```sql
-- 保留字段，但标记为已废弃
ALTER TABLE roadmap_metadata 
    ADD COLUMN task_id_deprecated VARCHAR;
```

**方案 B：完全移除（更干净）**
```sql
-- 移除 task_id 字段
ALTER TABLE roadmap_metadata DROP COLUMN task_id;

-- 通过 roadmap_task_links 查询最新任务
```

我**推荐方案 B**（完全解耦）

#### 3. `roadmap_tasks` 表（无需修改）

```sql
-- 当前表结构已经足够
CREATE TABLE roadmap_tasks (
    task_id VARCHAR PRIMARY KEY,
    user_id VARCHAR NOT NULL,
    status VARCHAR DEFAULT 'pending',
    current_step VARCHAR DEFAULT 'init',
    user_request JSON,
    roadmap_id VARCHAR,  -- 允许为 NULL（intent_analysis 后填写）
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

---

## 🔧 实施步骤

### 第 1 步：数据库迁移

**创建文件**: `backend/alembic/versions/XXXX_add_roadmap_task_links.py`

```python
"""添加 roadmap_task_links 表实现多对多关系"""

def upgrade():
    # 1. 创建表
    op.create_table(
        'roadmap_task_links',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('roadmap_id', sa.String(), nullable=False),
        sa.Column('task_id', sa.String(), nullable=False),
        sa.Column('task_type', sa.String(), nullable=False),
        sa.Column('concept_id', sa.String(), nullable=True),
        sa.Column('content_type', sa.String(), nullable=True),
        sa.Column('created_at', sa.DateTime(), server_default=sa.func.now()),
    )
    
    # 2. 创建索引
    op.create_index('idx_roadmap_task_links_roadmap_id', 'roadmap_task_links', 
                    ['roadmap_id', 'created_at'])
    op.create_index('idx_roadmap_task_links_task_id', 'roadmap_task_links', ['task_id'])
    
    # 3. 添加唯一约束
    op.create_unique_constraint('uq_roadmap_task_links', 'roadmap_task_links', 
                                ['roadmap_id', 'task_id'])
    
    # 4. 迁移现有数据
    op.execute("""
        INSERT INTO roadmap_task_links (roadmap_id, task_id, task_type, created_at)
        SELECT roadmap_id, task_id, 'creation', created_at
        FROM roadmap_metadata
        WHERE task_id IS NOT NULL
    """)
```

### 第 2 步：Repository 层更新

**文件**: `backend/app/db/repositories/roadmap_repo.py`

```python
class RoadmapRepository:
    
    async def link_task_to_roadmap(
        self,
        roadmap_id: str,
        task_id: str,
        task_type: str,
        concept_id: str | None = None,
        content_type: str | None = None,
    ) -> None:
        """
        将任务关联到路线图
        
        Args:
            roadmap_id: 路线图 ID
            task_id: 任务 ID
            task_type: 任务类型（'creation', 'retry_tutorial', 'retry_resources', 'retry_quiz'）
            concept_id: 概念 ID（单 Concept 重试时需要）
            content_type: 内容类型（单 Concept 重试时需要）
        """
        query = text("""
            INSERT INTO roadmap_task_links (roadmap_id, task_id, task_type, concept_id, content_type)
            VALUES (:roadmap_id, :task_id, :task_type, :concept_id, :content_type)
            ON CONFLICT (roadmap_id, task_id) DO NOTHING
        """)
        await self.session.execute(query, {...})
    
    async def get_active_tasks_for_roadmap(self, roadmap_id: str) -> list[RoadmapTask]:
        """
        获取路线图的所有活跃任务（包括重试任务）
        """
        query = text("""
            SELECT t.*
            FROM roadmap_tasks t
            JOIN roadmap_task_links l ON t.task_id = l.task_id
            WHERE l.roadmap_id = :roadmap_id
            AND t.status IN ('pending', 'processing', 'human_review_pending')
            ORDER BY l.created_at DESC
        """)
        # ...
```

### 第 3 步：修复重试端点

**文件**: `backend/app/api/v1/endpoints/generation.py`

```python
@router.post("/{roadmap_id}/concepts/{concept_id}/tutorial/retry")
async def retry_tutorial(...):
    task_id = _generate_retry_task_id(roadmap_id, concept_id, "tutorial")
    
    # ✅ 修复 1：创建任务记录
    async with repo_factory.create_session() as session:
        task_repo = repo_factory.create_task_repo(session)
        await task_repo.create_task(
            task_id=task_id,
            user_id=concept.user_id,
            user_request={
                "type": "retry_tutorial",
                "roadmap_id": roadmap_id,
                "concept_id": concept_id,
                "preferences": request.preferences.model_dump(mode='json'),
            },
        )
        await task_repo.update_task_status(
            task_id=task_id,
            status="processing",
            current_step="tutorial_generation",
            roadmap_id=roadmap_id,
        )
        
        # ✅ 修复 2：关联任务到路线图
        roadmap_repo = repo_factory.create_roadmap_repo(session)
        await roadmap_repo.link_task_to_roadmap(
            roadmap_id=roadmap_id,
            task_id=task_id,
            task_type="retry_tutorial",
            concept_id=concept_id,
            content_type="tutorial",
        )
        
        await session.commit()
    
    try:
        # 生成教程...
        
        # ✅ 修复 3：完成时更新任务状态
        async with repo_factory.create_session() as session:
            task_repo = repo_factory.create_task_repo(session)
            await task_repo.update_task_status(
                task_id=task_id,
                status="completed",
                current_step="completed",
            )
            await session.commit()
            
    except Exception as e:
        # ✅ 修复 4：失败时更新任务状态
        async with repo_factory.create_session() as session:
            task_repo = repo_factory.create_task_repo(session)
            await task_repo.update_task_status(
                task_id=task_id,
                status="failed",
                current_step="failed",
                error_message=str(e),
            )
            await session.commit()
        raise
```

### 第 4 步：修复僵尸状态检测

**文件**: `backend/app/api/v1/roadmap.py`

```python
@router.get("/{roadmap_id}/status-check")
async def check_roadmap_status_quick(roadmap_id: str, ...):
    """
    快速检查路线图状态，检测僵尸状态
    
    改进：检查所有与该路线图相关的活跃任务（包括重试任务）
    """
    repo = RoadmapRepository(db)
    metadata = await repo.get_roadmap_metadata(roadmap_id)
    
    # ✅ 修复：获取所有活跃任务（不只是 metadata.task_id）
    active_tasks = await repo.get_active_tasks_for_roadmap(roadmap_id)
    has_active_task = len(active_tasks) > 0
    
    if has_active_task:
        return {
            "roadmap_id": roadmap_id,
            "has_active_task": True,
            "active_tasks": [
                {
                    "task_id": task.task_id,
                    "status": task.status,
                    "current_step": task.current_step,
                }
                for task in active_tasks
            ],
            "stale_concepts": [],
        }
    
    # 没有活跃任务，检查僵尸概念
    # ...
```

---

## 📊 改进对比

| 方面 | 改进前 | 改进后 |
|------|-------|--------|
| **Roadmap-Task 关系** | 1:1（只有创建任务） | 1:N（创建 + 多次重试） |
| **重试任务持久化** | ❌ 未保存到数据库 | ✅ 保存到 `roadmap_tasks` + 关联 |
| **僵尸状态检测** | ❌ 误报 | ✅ 准确（检查所有任务） |
| **审计追踪** | ❌ 缺少重试历史 | ✅ 完整历史 |
| **任务状态查询** | ❌ 无法查询重试任务 | ✅ 可查询所有任务 |
| **执行日志** | ❌ 重试任务无日志 | ✅ 完整日志 |
| **WebSocket 恢复** | ⚠️ 仅通过 WebSocket | ✅ 可从数据库恢复 |

---

## 🎯 迁移策略

### 阶段 1：Schema 迁移（无破坏性变更）
1. 添加 `roadmap_task_links` 表
2. 迁移现有数据
3. 保留 `roadmap_metadata.task_id` 以向后兼容

### 阶段 2：Repository 更新
1. 添加新的关联和查询方法
2. 更新现有代码使用新方法

### 阶段 3：端点更新
1. 更新重试端点以持久化任务
2. 更新僵尸状态检测逻辑

### 阶段 4：清理（可选）
1. 废弃 `roadmap_metadata.task_id` 字段
2. 添加迁移以删除该字段（验证后）

---

## 🧪 测试清单

### 数据库迁移
- [ ] 迁移创建 `roadmap_task_links` 表
- [ ] 迁移填充现有数据
- [ ] 索引正确创建
- [ ] 回滚正常工作

### Repository 层
- [ ] `link_task_to_roadmap()` 正确插入关联
- [ ] `get_active_tasks_for_roadmap()` 只返回活跃任务
- [ ] `get_all_tasks_for_roadmap()` 返回所有任务
- [ ] 重复关联被正确处理（ON CONFLICT）

### 重试端点
- [ ] `retry_tutorial` 创建任务记录
- [ ] `retry_resources` 创建任务记录
- [ ] `retry_quiz` 创建任务记录
- [ ] 完成时任务状态更新
- [ ] 失败时任务状态更新
- [ ] 关联正确创建

### 僵尸状态检测
- [ ] 重试任务活跃时无误报
- [ ] 无任务活跃时正确识别僵尸概念
- [ ] 响应中返回所有活跃任务

### 端到端
- [ ] 创建路线图 → 任务已关联
- [ ] 重试教程 → 新任务创建并关联
- [ ] 重试期间检查状态 → 无误报
- [ ] 切换 tab 后返回 → 状态准确
- [ ] 任务被 kill → 僵尸状态正确检测

---

## 🎉 总结

你的分析完全正确！这个重构方案：

1. ✅ **解耦**了 roadmap 和 task 的关系（1:N 而非 1:1）
2. ✅ **修复**了重试任务持久化问题
3. ✅ **实现**了准确的僵尸状态检测
4. ✅ **保留**了完整的审计追踪
5. ✅ **保持**了迁移期间的向后兼容性
6. ✅ **简化**了未来的任务管理

**核心改进**：
- 一个路线图可以有多个任务（创建 + 多次重试）
- 所有任务都持久化到数据库
- 僵尸状态检测检查所有活跃任务，而不只是创建任务

**推荐实施**！

---

**详细文档**: `doc/ROADMAP_TASK_ARCHITECTURE_REDESIGN.md`

