# 重试任务状态更新修复 - 任务状态不同步和WebSocket通知缺失

## 问题现象

**症状：**
1. 用户点击重试按钮后，Celery接收到任务
2. 但任务状态仍显示"cancelled"
3. `completed_at`仍有值，`error_message`仍是"Task cancelled by user"
4. 前端任务详情页没有实时更新

**用户体验：**
- 看起来任务没有开始重试
- 没有进度反馈
- 页面静止不动

## 第一性原理分析

### 完整问题链

```
1. API层（retry.py）
   ├─ 检测到21个需要重试的concepts ✅
   ├─ 调用Celery任务 ✅
   ├─ 返回response {"status": "processing"} ⚠️（只是JSON，没更新DB）
   └─ ❌ 没有更新数据库状态
   └─ ❌ 没有发送WebSocket通知

2. 数据库
   ├─ status: "cancelled"  ← 保持不变
   ├─ completed_at: "2025-12-31 16:55:42"  ← 保持不变
   └─ error_message: "Task cancelled by user"  ← 保持不变

3. Worker层（retry_service.py）
   ├─ 接收任务，发送WebSocket ✅
   ├─ 但没有更新数据库状态为"processing" ❌
   ├─ 处理21个concepts...
   └─ 结束时才更新状态为"completed" ✅

4. 前端（TaskDetailPage）
   ├─ 收到API response（但不更新taskInfo）
   ├─ WebSocket连接建立
   ├─ 收到Worker的WebSocket消息
   └─ 但taskInfo仍是"cancelled"，显示不一致 ❌
```

### 根本原因1：API层缺少状态更新

#### Cancelled任务重启（有完整流程）

```python
# backend/app/api/v1/endpoints/retry.py (line 514-534)

# ✅ 1. 更新数据库状态
await task_repo.update_task_status(
    task_id=task_id,
    status="processing",
    current_step="content_generation_queued",
    roadmap_id=roadmap_id,
)
await db.commit()

# ✅ 2. 发送WebSocket通知
await notification_service.publish_progress(
    task_id=task_id,
    step="content_generation_queued",
    status="processing",
    message=f"Restarting content generation...",
    extra_data={...},
)

# ✅ 3. 调用Celery任务
celery_task = generate_roadmap_content.delay(...)
```

#### Content Retry（缺失流程）

```python
# backend/app/api/v1/endpoints/retry.py (line 608-617)

# ❌ 1. 没有更新数据库状态
# ❌ 2. 没有发送WebSocket通知

# ✅ 3. 调用Celery任务
celery_task = retry_failed_content_task.delay(...)

# ⚠️ 4. 返回response（但只是JSON，没有实际更新数据库）
return {"status": "processing", ...}
```

**问题：** Content Retry分支缺少状态更新和WebSocket通知。

### 根本原因2：update_task_status不清除完成标记

当任务状态从"cancelled"变为"processing"时：

```python
# backend/app/db/repositories/task_repo.py (line 252-270)

update_data = {
    "status": status,  # 更新为"processing"
    "current_step": current_step,
    "updated_at": beijing_now(),
}

# 任务完成时设置 completed_at
if status in ("completed", "partial_failure", "failed", "cancelled"):
    update_data["completed_at"] = beijing_now()

# ❌ 但没有清除 completed_at 当 status == "processing"
# ❌ 也没有清除 error_message
```

**结果：**
- `status` 更新为 "processing" ✅
- `completed_at` 仍然是旧值 ❌
- `error_message` 仍然是 "Task cancelled by user" ❌

**前端判断：**
- 检查到 `completed_at` 有值 → 认为任务已完成
- 显示"cancelled"状态，不显示进度更新

## 修复方案

### 修复1：API层添加状态更新和WebSocket通知

```python
# backend/app/api/v1/endpoints/retry.py

# 更新任务状态为 processing（重要：必须在调用Celery前更新）
await task_repo.update_task_status(
    task_id=task_id,
    status="processing",
    current_step="content_retry_queued",
    roadmap_id=roadmap_id,
)
await db.commit()

# 发送 WebSocket 通知，告知前端任务已重新开始
from app.services.notification_service import notification_service
await notification_service.publish_progress(
    task_id=task_id,
    step="content_retry_queued",
    status="processing",
    message=f"Retrying {total_items} failed content items",
    extra_data={
        "roadmap_id": roadmap_id,
        "total_items": total_items,
        "items_by_type": {k: len(v) for k, v in items_to_retry.items()},
        "recovery_type": "content_retry",
    },
)

# 分发 Celery 任务进行内容重试
celery_task = retry_failed_content_task.delay(...)
```

### 修复2：update_task_status清除完成标记

```python
# backend/app/db/repositories/task_repo.py

# 任务完成时设置 completed_at（包括取消状态）
if status in ("completed", "partial_failure", "failed", "cancelled"):
    update_data["completed_at"] = beijing_now()
# 任务重新开始时清除 completed_at 和 error_message（重要：重试时恢复到处理中状态）
elif status == "processing":
    update_data["completed_at"] = None
    # 只在没有显式传入error_message时才清除（避免覆盖新的错误消息）
    if error_message is None:
        update_data["error_message"] = None
```

同样的修复也应用到 `roadmap_repo.py`。

## 修复效果对比

### 修复前

```
用户点击重试
  ↓
API调用Celery
  ↓
返回response {"status": "processing"}（但不更新DB）
  ↓
数据库仍是：status="cancelled", completed_at=有值
  ↓
Worker发送WebSocket
  ↓
前端收到消息但taskInfo仍是"cancelled" ❌
  ↓
用户看不到任何变化
```

### 修复后

```
用户点击重试
  ↓
API更新数据库：status="processing", completed_at=None ✅
  ↓
API发送WebSocket通知 ✅
  ↓
前端立即收到状态更新 ✅
  ↓
前端显示"重试中..." ✅
  ↓
Worker开始处理
  ↓
Worker发送进度更新
  ↓
前端实时显示进度 ✅
```

## 适用场景

### 场景1：重试cancelled任务

```
任务被取消 → 用户点击重试 → 状态应立即变为processing
```

修复后：✅ 立即更新状态，清除completed_at和error_message

### 场景2：重试部分失败任务

```
21个concept中10个失败 → 重试失败的10个 → 状态应显示重试中
```

修复后：✅ 状态更新，WebSocket实时推送进度

### 场景3：前端实时反馈

```
用户点击重试 → 应该立即看到"重试中" → 进度条更新
```

修复后：✅ 立即反馈，实时更新

## 验证方法

### 1. 查看数据库

```sql
-- 重试前
SELECT task_id, status, completed_at, error_message 
FROM roadmap_tasks 
WHERE task_id = '779f75d3-...';
-- status: "cancelled"
-- completed_at: "2025-12-31 16:55:42"
-- error_message: "Task cancelled by user"

-- 重试后（立即查询）
-- status: "processing"
-- completed_at: NULL
-- error_message: NULL
```

### 2. 查看API日志

```bash
# 应该看到
content_retry_dispatched task_id=... total_items=21
task_status_updated task_id=... status=processing
websocket_notification_sent task_id=... step=content_retry_queued
```

### 3. 查看前端

```javascript
// WebSocket消息
{
  "type": "progress",
  "step": "content_retry_queued",
  "status": "processing",
  "message": "Retrying 21 failed content items",
  "data": {
    "roadmap_id": "...",
    "total_items": 21,
    "recovery_type": "content_retry"
  }
}

// TaskInfo更新
{
  "status": "processing",
  "current_step": "content_retry_queued",
  "completed_at": null,
  "error_message": null
}
```

## 相关修复

本修复与以下问题相关：

1. **重试逻辑修复** (`20251231_任务重试逻辑修复.md`)
   - 主应用传递items_to_retry给Worker
   - 解决检测逻辑不一致

2. **连接池耗尽** (`20251231_Railway连接池耗尽修复.md`)
   - 根本原因：教程保存失败但status未标记
   - 本修复确保重试时状态正确更新

## 设计改进建议

### 统一状态转换逻辑

**当前问题：** 状态转换逻辑分散在多个地方
- API层：手动调用update_task_status
- Worker层：结束时更新状态
- 不同分支有不同的处理

**改进方案：** 使用状态机模式

```python
class TaskStateMachine:
    """任务状态机"""
    
    TRANSITIONS = {
        ("cancelled", "processing"): {
            "clear_fields": ["completed_at", "error_message"],
            "notify": True,
        },
        ("failed", "processing"): {
            "clear_fields": ["completed_at", "error_message"],
            "notify": True,
        },
        ("processing", "completed"): {
            "set_fields": {"completed_at": "now"},
            "notify": True,
        },
    }
    
    async def transition(self, task_id: str, from_status: str, to_status: str):
        """执行状态转换"""
        transition = self.TRANSITIONS.get((from_status, to_status))
        if not transition:
            raise ValueError(f"Invalid transition: {from_status} → {to_status}")
        
        # 应用转换规则
        # ...
```

**优势：**
- 集中管理状态转换规则
- 自动处理字段清除/设置
- 统一WebSocket通知
- 易于测试和维护

## 总结

| 维度 | 问题 | 修复 |
|------|------|------|
| **API层** | 不更新状态，不发送通知 | 添加状态更新和WebSocket通知 |
| **DB层** | 不清除completed_at | 清除完成标记和错误信息 |
| **前端** | 看不到状态变化 | 实时收到更新 |
| **用户体验** | 点击后无反应 | 立即反馈，实时进度 |
| **适用场景** | 所有重试场景 | 统一处理 |

**核心教训：**
> 状态转换必须是原子操作，包括：
> 1. 数据库字段更新（包括清除旧值）
> 2. WebSocket通知
> 3. 日志记录
> 
> 任何遗漏都会导致前后端状态不一致。

