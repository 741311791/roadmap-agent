# Celery 异步事件循环冲突修复

**修复日期**: 2024-12-31  
**问题类型**: 运行时错误 - 事件循环冲突  
**影响范围**: Celery Worker 异常处理

---

## 问题描述

### 错误信息

```
[2025-12-31 02:45:09,728: WARNING/ForkPoolWorker-2] 
notification_publish_failed error="Task <Task pending name='Task-64' 
coro=<_mark_task_failed() running at workflow_resume_tasks.py:442> 
cb=[_run_until_complete_cb()]> got Future <Future pending> attached to a different loop"
```

### 根本原因

在 Celery Worker 的异常处理中调用 `_mark_task_failed` 时，该函数内部通过 `notification_service.publish_failed` 发送 WebSocket 通知。`_publish` 方法使用了 `asyncio.wait_for`，它会创建新的 Task。在异常处理上下文中，这个 Task 可能被附加到不同的事件循环，导致 RuntimeError。

### 触发场景

1. Celery 任务 `resume_after_review` 或 `resume_from_checkpoint` 执行失败
2. 在 `except` 块中调用 `run_async(_mark_task_failed(...))`
3. `_mark_task_failed` 调用 `notification_service.publish_failed`
4. `_publish` 方法内部的 `asyncio.wait_for` 创建 Task，触发事件循环冲突

---

## 修复方案

### 1. 增强 `_mark_task_failed` 的容错性

**文件**: `backend/app/tasks/workflow_resume_tasks.py`

**修改内容**:
- 分离数据库更新和通知发送，确保关键操作（状态更新）优先完成
- 对通知失败进行单独捕获，仅记录警告，不抛出异常
- 明确注释：在异常处理上下文中，通知失败是可以接受的

```python
async def _mark_task_failed(task_id: str, error_message: str):
    # 1. 先更新数据库状态（关键操作）
    try:
        repo_factory = RepositoryFactory()
        async with repo_factory.create_session() as session:
            task_repo = repo_factory.create_task_repo(session)
            await task_repo.update_task_status(...)
        logger.info("task_marked_as_failed", ...)
    except Exception as e:
        logger.error("failed_to_update_task_status", ...)
    
    # 2. 尝试发送通知（非关键操作）
    try:
        await notification_service.publish_failed(...)
    except Exception as e:
        logger.warning("failed_to_send_failure_notification", ...)
```

### 2. 捕获调用点的异常

**文件**: `backend/app/tasks/workflow_resume_tasks.py`

**修改位置**:
- `resume_after_review` 函数的 `except` 块
- `resume_from_checkpoint` 函数的 `except` 块

**修改内容**:
```python
except Exception as e:
    logger.error("resume_xxx_failed", ...)
    
    # 捕获 _mark_task_failed 可能的事件循环冲突
    try:
        run_async(_mark_task_failed(task_id, str(e)))
    except Exception as mark_error:
        logger.error("failed_to_mark_task_as_failed", ...)
    
    return {"success": False, "status": "failed", "error": str(e)}
```

### 3. 优化通知服务的事件循环处理

**文件**: `backend/app/services/notification_service.py`

**修改内容**:
- 在 `_publish` 方法中显式捕获 `RuntimeError`（事件循环冲突）
- 添加详细的错误分类日志
- 确保任何通知失败都不会抛出异常

```python
async def _publish(self, task_id: str, event: dict):
    try:
        await self._ensure_connected()
        channel = self._get_channel(task_id)
        message = json.dumps(event, ensure_ascii=False)
        
        await asyncio.wait_for(
            redis_client._client.publish(channel, message),
            timeout=5.0
        )
        
    except asyncio.TimeoutError:
        logger.error("notification_publish_timeout", ...)
    except RuntimeError as e:
        # 事件循环冲突
        logger.error("notification_publish_failed", 
                    error=f"Event loop conflict: {str(e)}")
    except Exception as e:
        logger.error("notification_publish_failed", ...)
```

---

## 设计理念

### 容错层次

1. **关键操作**（数据库状态更新）：优先执行，失败需要记录错误日志
2. **非关键操作**（WebSocket 通知）：失败仅记录警告，不影响核心流程
3. **异常处理上下文**：多层 try-except 保护，确保不会因为次要操作失败导致主流程中断

### 事件循环最佳实践

1. **避免在异常处理中创建 Task**: `asyncio.wait_for` 和 `asyncio.create_task` 在异常上下文中可能触发冲突
2. **明确事件循环所有权**: Celery Worker 使用进程级事件循环（`get_worker_loop`）
3. **优雅降级**: 通知系统失败不应影响核心工作流

---

## 测试建议

### 1. 手动触发异常

```python
# 在 _resume_workflow_after_review 中注入异常
async def _resume_workflow_after_review(...):
    raise Exception("Simulated failure for testing")
```

### 2. 验证行为

- 任务状态正确更新为 `failed`
- 错误日志正确记录
- 即使通知失败，任务状态仍然正确

### 3. 监控日志

观察以下日志事件：
- `task_marked_as_failed`: 数据库更新成功
- `failed_to_send_failure_notification`: 通知失败（可接受）
- `failed_to_mark_task_as_failed`: 整个 `_mark_task_failed` 失败（需关注）

---

## 影响评估

### 修复前
- Celery Worker 在任务失败时可能因为通知系统的事件循环冲突而崩溃
- 错误信息 "Future attached to a different loop" 频繁出现
- 任务状态可能无法正确更新

### 修复后
- 异常处理更加健壮，通知失败不会影响核心流程
- 数据库状态更新与通知发送解耦
- 事件循环冲突被优雅处理，仅记录日志

---

## 相关文件

- `backend/app/tasks/workflow_resume_tasks.py`
- `backend/app/services/notification_service.py`

---

## 后续优化建议

1. **考虑使用 fire-and-forget 模式**: 对于非关键通知，可以使用 `asyncio.create_task` 并立即分离，避免等待结果
2. **Redis 连接池优化**: 确保 Redis 客户端在每个事件循环中正确初始化
3. **监控告警**: 对 `failed_to_send_failure_notification` 建立监控，频繁出现时需要检查 Redis 连接状态

